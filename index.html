<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM AI PREDICTOR - SURYA S3 ULTRA PRO MAX</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Exo+2:wght@400;600&display=swap');

        :root {
            --quantum-blue: #00f0ff;
            --ai-purple: #9d00ff;
            --matrix-green: #00ff88;
            --error-red: #ff3366;
            --warning-yellow: #ffcc00;
            --success-green: #00ff88;
            --info-blue: #00aaff;
            --dark-space: #0a0a1a;
            --deep-space: #000011;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: linear-gradient(135deg, var(--deep-space), var(--dark-space));
            color: #ffffff;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1, h2, h3 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            text-align: center;
            background: linear-gradient(90deg, var(--quantum-blue), var(--ai-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
            margin-bottom: 1.5rem;
            letter-spacing: 1px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: rgba(10, 10, 30, 0.7);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 16px;
            padding: 2rem;
            margin: 2rem 0;
            backdrop-filter: blur(10px);
            position: relative;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.15);
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 18px;
            background: linear-gradient(45deg, var(--quantum-blue), var(--ai-purple), var(--matrix-green));
            z-index: -1;
            opacity: 0.3;
            animation: borderGlow 8s linear infinite;
            background-size: 400% 400%;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid var(--quantum-blue);
        }

        .status-item {
            display: flex;
            align-items: center;
        }

        .status-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-icon.active {
            background-color: var(--matrix-green);
            box-shadow: 0 0 10px var(--matrix-green);
        }

        .status-icon.warning {
            background-color: var(--warning-yellow);
            box-shadow: 0 0 10px var(--warning-yellow);
        }

        .status-icon.error {
            background-color: var(--error-red);
            box-shadow: 0 0 10px var(--error-red);
        }

        .countdown {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.8rem;
            text-align: center;
            margin: 1rem 0;
            color: var(--matrix-green);
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
            letter-spacing: 2px;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .prediction-card {
            background: rgba(20, 20, 50, 0.5);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(0, 240, 255, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 240, 255, 0.2);
        }

        .prediction-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--quantum-blue), var(--ai-purple));
        }

        .prediction-label {
            color: var(--quantum-blue);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .prediction-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            margin: 0.5rem 0;
            color: white;
        }

        .confidence-meter {
            height: 8px;
            background: rgba(0, 240, 255, 0.1);
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .confidence-level {
            height: 100%;
            background: linear-gradient(90deg, var(--ai-purple), var(--quantum-blue));
            border-radius: 4px;
            transition: width 1s ease;
        }

        .prediction-details {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.5rem;
        }

        .analysis-section {
            margin: 2rem 0;
        }

        .pattern-visualization {
            display: flex;
            height: 40px;
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
        }

        .pattern-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            transition: all 0.5s ease;
        }

        .pattern-segment.small {
            background: rgba(0, 240, 255, 0.7);
        }

        .pattern-segment.big {
            background: rgba(157, 0, 255, 0.7);
        }

        .heatmap-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            margin: 1.5rem 0;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.4);
        }

        .heatmap-cell::after {
            content: attr(data-count);
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 0 3px;
            border-radius: 3px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: rgba(20, 20, 50, 0.3);
            border-radius: 10px;
            padding: 1.2rem;
            border: 1px solid rgba(0, 240, 255, 0.1);
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--quantum-blue);
            margin: 0.5rem 0;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }

        .trend-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 1.2rem;
        }

        .trend-up {
            color: var(--success-green);
        }

        .trend-down {
            color: var(--error-red);
        }

        .trend-neutral {
            color: var(--warning-yellow);
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .quantum-button {
            background: linear-gradient(90deg, var(--ai-purple), var(--quantum-blue));
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 180px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(157, 0, 255, 0.3);
        }

        .quantum-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 240, 255, 0.4);
        }

        .quantum-button:active {
            transform: translateY(0);
        }

        .quantum-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .quantum-button i {
            margin-right: 8px;
        }

        .spinner {
            border: 4px solid rgba(0, 240, 255, 0.2);
            border-top: 4px solid var(--quantum-blue);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message {
            text-align: center;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: bold;
        }

        .error-message {
            background: rgba(255, 51, 102, 0.2);
            border-left: 4px solid var(--error-red);
            color: var(--error-red);
            animation: pulse 2s infinite;
        }

        .warning-message {
            background: rgba(255, 204, 0, 0.2);
            border-left: 4px solid var(--warning-yellow);
            color: var(--warning-yellow);
        }

        .success-message {
            background: rgba(0, 255, 136, 0.2);
            border-left: 4px solid var(--success-green);
            color: var(--success-green);
        }

        .info-message {
            background: rgba(0, 170, 255, 0.2);
            border-left: 4px solid var(--info-blue);
            color: var(--info-blue);
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: rgba(20, 20, 50, 0.3);
        }

        .data-table th, .data-table td {
            padding: 1rem;
            text-align: center;
            border: 1px solid rgba(0, 240, 255, 0.1);
        }

        .data-table th {
            background: linear-gradient(90deg, rgba(157, 0, 255, 0.3), rgba(0, 240, 255, 0.3));
            font-family: 'Orbitron', sans-serif;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .data-table tr:nth-child(even) {
            background: rgba(0, 240, 255, 0.05);
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 5px;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: rgba(10, 10, 30, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--quantum-blue);
            font-size: 0.9rem;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Notification system */
        .notification-bell {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 50, 0.8);
            border: 1px solid var(--quantum-blue);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
            transition: all 0.3s ease;
        }

        .notification-bell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
        }

        .notification-bell i {
            color: var(--quantum-blue);
            font-size: 1.5rem;
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--error-red);
            color: white;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
        }

        .notification-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(10, 10, 30, 0.95);
            border: 1px solid var(--quantum-blue);
            border-radius: 12px;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            padding: 1.5rem;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
            display: none;
            backdrop-filter: blur(10px);
        }

        .notification-panel h3 {
            margin-top: 0;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
        }

        .notification-item {
            padding: 1rem 0;
            border-bottom: 1px solid rgba(0, 240, 255, 0.1);
        }

        .notification-item:last-child {
            border-bottom: none;
        }

        .notification-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }

        .notification-title i {
            margin-right: 8px;
        }

        .notification-message {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 0.5rem;
        }

        .notification-time {
            font-size: 0.8rem;
            color: rgba(0, 240, 255, 0.7);
            text-align: right;
        }

        .notification-item.error .notification-title {
            color: var(--error-red);
        }

        .notification-item.warning .notification-title {
            color: var(--warning-yellow);
        }

        .notification-item.success .notification-title {
            color: var(--success-green);
        }

        .notification-item.info .notification-title {
            color: var(--info-blue);
        }

        /* Settings panel */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.98);
            border: 1px solid var(--quantum-blue);
            border-radius: 16px;
            padding: 2rem;
            z-index: 1001;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.4);
            display: none;
            backdrop-filter: blur(10px);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
        }

        .settings-close {
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--quantum-blue);
            transition: all 0.3s ease;
        }

        .settings-close:hover {
            transform: rotate(90deg);
        }

        .settings-group {
            margin-bottom: 1.5rem;
        }

        .settings-group h3 {
            text-align: left;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .settings-row label {
            flex: 1;
            font-size: 0.9rem;
        }

        .settings-row select, .settings-row input[type="text"], .settings-row input[type="number"] {
            background: rgba(20, 20, 50, 0.5);
            border: 1px solid var(--quantum-blue);
            color: white;
            padding: 0.7rem;
            border-radius: 6px;
            width: 200px;
        }

        .settings-row input[type="range"] {
            width: 200px;
            margin-right: 1rem;
        }

        .settings-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--quantum-blue);
        }

        .settings-actions {
            display: flex;
            justify-content: center;
            margin-top: 2rem;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .prediction-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .countdown {
                font-size: 2rem;
            }

            .prediction-value {
                font-size: 2rem;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .quantum-button {
                width: 100%;
                max-width: 300px;
            }

            .notification-panel {
                width: 60%;
                right: 5%;
            }

            .data-table th, .data-table td {
                padding: 0.7rem;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }

            .countdown {
                font-size: 1.8rem;
            }

            .prediction-value {
                font-size: 1.8rem;
            }

            .settings-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .settings-row select, .settings-row input {
                width: 100%;
                margin-top: 0.5rem;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="notification-bell" id="notificationBell">
        <i class="fas fa-bell"></i>
        <div class="notification-badge" id="notificationBadge">0</div>
    </div>
    <div class="notification-panel" id="notificationPanel">
        <h3><i class="fas fa-bell"></i> System Notifications</h3>
        <div id="notificationList"></div>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2><i class="fas fa-cog"></i> SYSTEM SETTINGS</h2>
            <span class="settings-close" id="settingsClose">&times;</span>
        </div>
        
        <div class="settings-group">
            <h3><i class="fas fa-brain"></i> Prediction Algorithm</h3>
            <div class="settings-row">
                <label for="algorithmType">Algorithm Type:</label>
                <select id="algorithmType">
                    <option value="basic">Basic Pattern</option>
                    <option value="advanced" selected>Advanced AI</option>
                    <option value="quantum">Quantum Neural Net</option>
                    <option value="hybrid">Hybrid AI</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="randomnessFactor">Randomness Factor: <span id="randomnessValue">15%</span></label>
                <input type="range" id="randomnessFactor" min="0" max="100" value="15">
            </div>
            <div class="settings-row">
                <label for="historyWeight">History Weight:</label>
                <input type="range" id="historyWeight" min="0" max="100" value="70">
                <span id="historyWeightValue">70%</span>
            </div>
        </div>
        
        <div class="settings-group">
            <h3><i class="fas fa-palette"></i> Display Options</h3>
            <div class="settings-row">
                <label for="themeSelect">Color Theme:</label>
                <select id="themeSelect">
                    <option value="default" selected>Quantum Blue</option>
                    <option value="matrix">Matrix Green</option>
                    <option value="purple">Deep Purple</option>
                    <option value="crimson">Crimson Red</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="animationsToggle">Enable Animations:</label>
                <input type="checkbox" id="animationsToggle" checked>
            </div>
            <div class="settings-row">
                <label for="darkModeToggle">Dark Mode:</label>
                <input type="checkbox" id="darkModeToggle" checked>
            </div>
        </div>
        
        <div class="settings-group">
            <h3><i class="fas fa-bell"></i> Notifications</h3>
            <div class="settings-row">
                <label for="soundToggle">Enable Sound Alerts:</label>
                <input type="checkbox" id="soundToggle" checked>
            </div>
            <div class="settings-row">
                <label for="vibrationToggle">Enable Vibration:</label>
                <input type="checkbox" id="vibrationToggle">
            </div>
            <div class="settings-row">
                <label for="notificationFrequency">Alert Frequency:</label>
                <select id="notificationFrequency">
                    <option value="all">All Notifications</option>
                    <option value="important" selected>Important Only</option>
                    <option value="none">None</option>
                </select>
            </div>
        </div>
        
        <div class="settings-actions">
            <button class="quantum-button" id="saveSettings"><i class="fas fa-save"></i> SAVE SETTINGS</button>
        </div>
    </div>

    <div class="container">
        <h1>QUANTUM AI PREDICTOR</h1>
        <h2>SURYA S3 ULTRA PRO MAX</h2>
        
        <div class="status-bar">
            <div class="status-item">
                <div class="status-icon active" id="systemStatusIcon"></div>
                <span id="systemStatusText">Initializing quantum network...</span>
            </div>
            <div class="status-item">
                <i class="fas fa-database" style="color: var(--quantum-blue); margin-right: 8px;"></i>
                <span id="dataStatus">Loading historical data...</span>
            </div>
            <div class="status-item">
                <i class="fas fa-shield-alt" style="color: var(--matrix-green); margin-right: 8px;"></i>
                <span>Security: Quantum Encrypted</span>
            </div>
        </div>
        
        <div class="card">
            <h2>QUANTUM PREDICTION ENGINE</h2>
            <div id="loadingSpinner" class="spinner" style="display: none;"></div>
            
            <div id="errorMessage" class="message error-message"></div>
            <div id="warningMessage" class="message warning-message"></div>
            <div id="successMessage" class="message success-message"></div>
            <div id="infoMessage" class="message info-message"></div>
            
            <div class="countdown" id="timeRemaining">
                SYNCING WITH QUANTUM NETWORK...
            </div>
            
            <div class="prediction-grid">
                <div class="prediction-card">
                    <div class="prediction-label">Current Prediction</div>
                    <div id="predictedNumber" class="prediction-value">--</div>
                    <div class="prediction-details">
                        <span id="predictionCategory">Category: --</span>
                        <span class="tooltip">ⓘ<span class="tooltip-text">Predicted number category (Small: 0-4, Big: 5-9)</span></span>
                    </div>
                    <div class="confidence-meter">
                        <div id="confidenceLevel" class="confidence-level" style="width: 0%"></div>
                    </div>
                    <div class="prediction-details">Confidence Level: <span id="confidenceValue">--%</span></div>
                </div>
                
                <div class="prediction-card">
                    <div class="prediction-label">Pattern Recognition</div>
                    <div id="patternIndicator" class="prediction-value">--</div>
                    <div class="prediction-details">
                        <span id="patternStrength">Strength: --</span>
                        <span class="tooltip">ⓘ<span class="tooltip-text">Identified pattern strength based on historical data</span></span>
                    </div>
                    <div class="pattern-visualization">
                        <div class="pattern-segment small" id="smallPatternBar" style="width: 50%">Small</div>
                        <div class="pattern-segment big" id="bigPatternBar" style="width: 50%">Big</div>
                    </div>
                </div>
                
                <div class="prediction-card">
                    <div class="prediction-label">Trend Analysis</div>
                    <div id="trendIndicator" class="prediction-value">--</div>
                    <div class="prediction-details">
                        <span id="trendStrength">Momentum: --</span>
                        <span class="tooltip">ⓘ<span class="tooltip-text">Current trend direction and momentum</span></span>
                    </div>
                    <div class="prediction-details" id="trendDuration">Duration: --</div>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Predictions</div>
                    <div id="totalPredictions" class="stat-value">0</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">Accuracy Rate</div>
                    <div id="accuracyRate" class="stat-value">0%</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">Current Streak</div>
                    <div id="currentStreak" class="stat-value">0</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-label">Last Result</div>
                    <div id="lastResult" class="stat-value">--</div>
                </div>
            </div>
            
            <div class="analysis-section">
                <h3>Number Frequency Heatmap <span class="tooltip">ⓘ<span class="tooltip-text">Hot numbers appear more frequently in recent results</span></span></h3>
                <div class="heatmap-container" id="heatMap">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            
            <div class="button-group">
                <button id="manualRefresh" class="quantum-button"><i class="fas fa-sync-alt"></i> Refresh Data</button>
                <button id="settingsButton" class="quantum-button"><i class="fas fa-cog"></i> Settings</button>
                <button id="exportData" class="quantum-button"><i class="fas fa-file-export"></i> Export Data</button>
                <button id="advancedAnalysis" class="quantum-button"><i class="fas fa-chart-line"></i> Advanced Analysis</button>
            </div>
        </div>
        
        <div class="card">
            <h2>PREDICTION HISTORY MATRIX</h2>
            <div class="table-container">
                <table class="data-table" id="predictionHistoryTable">
                    <thead>
                        <tr>
                            <th>Issue</th>
                            <th>Predicted</th>
                            <th>Actual</th>
                            <th>Result</th>
                            <th>Timestamp</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="pagination">
                <button id="prevPage" class="quantum-button" disabled><i class="fas fa-chevron-left"></i> Previous</button>
                <button id="nextPage" class="quantum-button" disabled>Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
        
        <div class="card">
            <h2>QUANTUM DATA INTERFACE</h2>
            <div class="table-container">
                <table class="data-table" id="dataTable">
                    <thead>
                        <tr>
                            <th>Issue</th>
                            <th>Number</th>
                            <th>Pattern</th>
                            <th>Probability</th>
                            <th>Timestamp</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const elements = {
        tableBody: document.querySelector('#dataTable tbody'),
        predictedNumber: document.getElementById('predictedNumber'),
        predictionCategory: document.getElementById('predictionCategory'),
        confidenceLevel: document.getElementById('confidenceLevel'),
        confidenceValue: document.getElementById('confidenceValue'),
        timer: document.getElementById('timeRemaining'),
        historyTableBody: document.querySelector('#predictionHistoryTable tbody'),
        prevPageButton: document.getElementById('prevPage'),
        nextPageButton: document.getElementById('nextPage'),
        errorMessage: document.getElementById('errorMessage'),
        warningMessage: document.getElementById('warningMessage'),
        successMessage: document.getElementById('successMessage'),
        infoMessage: document.getElementById('infoMessage'),
        loadingSpinner: document.getElementById('loadingSpinner'),
        totalPredictions: document.getElementById('totalPredictions'),
        accuracyRate: document.getElementById('accuracyRate'),
        lastResult: document.getElementById('lastResult'),
        currentStreak: document.getElementById('currentStreak'),
        smallPatternBar: document.getElementById('smallPatternBar'),
        bigPatternBar: document.getElementById('bigPatternBar'),
        heatMap: document.getElementById('heatMap'),
        trendIndicator: document.getElementById('trendIndicator'),
        trendStrength: document.getElementById('trendStrength'),
        trendDuration: document.getElementById('trendDuration'),
        patternIndicator: document.getElementById('patternIndicator'),
        patternStrength: document.getElementById('patternStrength'),
        notificationBell: document.getElementById('notificationBell'),
        notificationPanel: document.getElementById('notificationPanel'),
        notificationBadge: document.getElementById('notificationBadge'),
        notificationList: document.getElementById('notificationList'),
        settingsButton: document.getElementById('settingsButton'),
        settingsPanel: document.getElementById('settingsPanel'),
        settingsClose: document.getElementById('settingsClose'),
        saveSettingsButton: document.getElementById('saveSettings'),
        manualRefreshButton: document.getElementById('manualRefresh'),
        exportDataButton: document.getElementById('exportData'),
        advancedAnalysisButton: document.getElementById('advancedAnalysis'),
        systemStatusIcon: document.getElementById('systemStatusIcon'),
        systemStatusText: document.getElementById('systemStatusText'),
        dataStatus: document.getElementById('dataStatus')
    };

    // Data state
    const state = {
        predictionHistory: [],
        lastPrediction: null,
        currentPrediction: null,
        currentPage: 0,
        itemsPerPage: 10,
        timerInterval: null,
        isFetching: false,
        systemStatus: 'initializing',
        notifications: [],
        currentStreak: 0,
        settings: {
            algorithmType: 'advanced',
            randomnessFactor: 15,
            historyWeight: 70,
            theme: 'default',
            animations: true,
            darkMode: true,
            sound: true,
            vibration: false,
            notificationFrequency: 'important'
        },
        heatMapNumbers: Array(10).fill(0),
        patternHistory: []
    };

    // Initialize the app
    function init() {
        try {
            updateSystemStatus('initializing', 'Initializing quantum neural network...');
            elements.loadingSpinner.style.display = 'block';

            // Load saved data from localStorage
            loadSavedData();
            
            // Initialize UI components
            initializeHeatMap();
            updateStats();
            updatePatternAnalysis();
            updateTrendAnalysis();
            updateUI();

            // Start the update cycle
            startUpdateCycle();
        } catch (error) {
            showError('System initialization failed: ' + error.message);
            console.error('Initialization error:', error);
        } finally {
            elements.loadingSpinner.style.display = 'none';
        }
    }

    // Load saved data from localStorage
    function loadSavedData() {
        const savedHistory = localStorage.getItem('predictionHistory');
        state.predictionHistory = savedHistory ? JSON.parse(savedHistory) : [];
        
        state.lastPrediction = JSON.parse(localStorage.getItem('lastPrediction'));
        state.currentPrediction = JSON.parse(localStorage.getItem('currentPrediction'));
        
        // Load settings
        const savedSettings = localStorage.getItem('systemSettings');
        if (savedSettings) {
            state.settings = JSON.parse(savedSettings);
            applySettingsToUI();
        }
        
        // Load notifications
        const savedNotifications = localStorage.getItem('notifications');
        if (savedNotifications) {
            state.notifications = JSON.parse(savedNotifications);
            updateNotificationBadge();
        }

        // Update data status
        elements.dataStatus.textContent = state.predictionHistory.length > 0 ? 
            `Loaded ${state.predictionHistory.length} historical records` : 
            'No historical data available';
    }

    // Apply settings to UI elements
    function applySettingsToUI() {
        document.getElementById('algorithmType').value = state.settings.algorithmType;
        document.getElementById('randomnessFactor').value = state.settings.randomnessFactor;
        document.getElementById('randomnessValue').textContent = state.settings.randomnessFactor + '%';
        document.getElementById('historyWeight').value = state.settings.historyWeight;
        document.getElementById('historyWeightValue').textContent = state.settings.historyWeight + '%';
        document.getElementById('themeSelect').value = state.settings.theme;
        document.getElementById('animationsToggle').checked = state.settings.animations;
        document.getElementById('darkModeToggle').checked = state.settings.darkMode;
        document.getElementById('soundToggle').checked = state.settings.sound;
        document.getElementById('vibrationToggle').checked = state.settings.vibration;
        document.getElementById('notificationFrequency').value = state.settings.notificationFrequency;
    }

    // Initialize heatmap
    function initializeHeatMap() {
        elements.heatMap.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const cell = document.createElement('div');
            cell.className = 'heatmap-cell';
            cell.textContent = i;
            cell.id = `heat-cell-${i}`;
            cell.setAttribute('data-count', '0');
            cell.style.backgroundColor = 'rgba(0, 240, 255, 0.1)';
            elements.heatMap.appendChild(cell);
        }
    }

    // Start the periodic update cycle
    function startUpdateCycle() {
        // Clear any existing interval
        if (state.timerInterval) {
            clearInterval(state.timerInterval);
        }

        // Immediate update
        updateData();

        // Set up periodic updates (every 10 seconds)
        state.timerInterval = setInterval(updateData, 2200);
    }

    // Main update function
    async function updateData() {
        if (state.isFetching) return;
        state.isFetching = true;
        updateSystemStatus('updating', 'Synchronizing with quantum interface...');
        elements.loadingSpinner.style.display = 'block';
        clearMessages();

        try {
            // Fetch the latest data
            const [emerData, gameIssueData] = await Promise.all([
                fetchNoAverageEmerdList(),
                fetchGameIssue()
            ]);

            // Process the data
            if (emerData && emerData.data && emerData.data.list && emerData.data.list.length > 0) {
                updateDataTable(emerData.data.list);
                processNewData(emerData.data.list);
                elements.dataStatus.textContent = `Synced ${emerData.data.list.length} new records`;
            } else {
                showWarning('No new data available from quantum interface');
            }

            if (gameIssueData && gameIssueData.data) {
                updateTimer(gameIssueData.data.endTime);
            } else {
                showWarning('Could not sync with time server');
            }

            updateUI();
            updateSystemStatus('operational', 'System operational - predictions active');
            showSuccess('Data synchronized successfully');
        } catch (error) {
            updateSystemStatus('error', 'Data synchronization failed');
            showError('Data synchronization failed: ' + error.message);
            console.error('Update error:', error);
        } finally {
            state.isFetching = false;
            elements.loadingSpinner.style.display = 'none';
        }
    }

    // Update the data table with new results
    function updateDataTable(dataList) {
        elements.tableBody.innerHTML = '';
        dataList.forEach(item => {
            const numberCategory = categorizeNumber(Number(item.number));
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.issueNumber}</td>
                <td>${item.number} (${numberCategory})</td>
                <td>${item.colour || '--'}</td>
                <td>${item.premium || '--'}</td>
                <td>${new Date().toLocaleTimeString()}</td>
            `;
            elements.tableBody.appendChild(row);
        });
    }

    // Process new data and update predictions
    function processNewData(dataList) {
        const latestItem = dataList[0];
        const latestIssue = latestItem.issueNumber;
        const latestActual = Number(latestItem.number);
        const actualCategory = categorizeNumber(latestActual);

        // Update heatmap counts
        state.heatMapNumbers[latestActual]++;
        updateHeatMap();

        // Check if we have a new issue
        if (!state.lastPrediction || state.lastPrediction.issueNumber !== latestIssue) {
            // If we had a previous prediction, record its accuracy
            if (state.lastPrediction) {
                const isCorrect = state.lastPrediction.category === actualCategory;
                
                // Update streak
                if (isCorrect) {
                    state.currentStreak++;
                    addNotification('Prediction Correct', 
                        `Successfully predicted ${state.lastPrediction.category} for issue ${latestIssue}`, 
                        'success');
                } else {
                    state.currentStreak = 0;
                    addNotification('Prediction Incorrect', 
                        `Predicted ${state.lastPrediction.category} but got ${actualCategory} for issue ${latestIssue}`, 
                        'error');
                }

                const newHistoryEntry = {
                    issueNumber: latestIssue,
                    predictedNumber: state.lastPrediction.number,
                    predictedCategory: state.lastPrediction.category,
                    actualNumber: latestActual,
                    actualCategory: actualCategory,
                    result: isCorrect ? '🏆' : '💥',
                    timestamp: new Date().toISOString()
                };

                state.predictionHistory.unshift(newHistoryEntry);
                
                // Keep only the last 100 entries to prevent memory issues
                if (state.predictionHistory.length > 100) {
                    state.predictionHistory = state.predictionHistory.slice(0, 100);
                }

                localStorage.setItem('predictionHistory', JSON.stringify(state.predictionHistory));
                updateStats();
                updatePatternAnalysis();
                updateTrendAnalysis();
            }

            // Generate a new prediction
            state.currentPrediction = generatePrediction();
            state.currentPrediction.issueNumber = latestIssue;
            localStorage.setItem('currentPrediction', JSON.stringify(state.currentPrediction));

            // Update last prediction reference
            state.lastPrediction = {
                issueNumber: latestIssue,
                number: state.currentPrediction.number,
                category: state.currentPrediction.category
            };
            localStorage.setItem('lastPrediction', JSON.stringify(state.lastPrediction));
            
            // Add notification for new prediction
            addNotification('New Prediction Generated', 
                `Predicted ${state.currentPrediction.category} (${state.currentPrediction.number}) for next issue with ${state.currentPrediction.confidence}% confidence`, 
                'info');
        }
    }

    // Update the timer display
    function updateTimer(endTime) {
        const endDate = new Date(endTime);
        const now = new Date();
        const remainingTimeMs = endDate - now;

        if (remainingTimeMs <= 0) {
            elements.timer.textContent = "00:00:00";
            // Trigger an immediate update when time runs out
            setTimeout(updateData, 2100);
        } else {
            const hours = String(Math.floor(remainingTimeMs / 3600000)).padStart(2, '0');
            const minutes = String(Math.floor((remainingTimeMs % 3600000) / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((remainingTimeMs % 60000) / 1000)).padStart(2, '0');
            elements.timer.textContent = `${hours}:${minutes}:${seconds}`;
        }
    }

    // Update the UI with current data
    function updateUI() {
        // Update prediction display
        if (state.currentPrediction) {
            elements.predictedNumber.textContent = state.currentPrediction.number;
            elements.predictionCategory.textContent = `BUY: ${state.currentPrediction.category}`;
            elements.confidenceValue.textContent = `${state.currentPrediction.confidence}%`;
            elements.confidenceLevel.style.width = `${state.currentPrediction.confidence}%`;
        } else {
            elements.predictedNumber.textContent = '--';
            elements.predictionCategory.textContent = 'Category: --';
            elements.confidenceValue.textContent = '--%';
            elements.confidenceLevel.style.width = '0%';
        }

        // Update history table
        updatePredictionHistoryTable();
    }

    // Update system status display
    function updateSystemStatus(status, message) {
        state.systemStatus = status;
        
        const statusClasses = {
            'initializing': 'warning',
            'loading': 'warning',
            'updating': 'warning',
            'operational': 'active',
            'error': 'error'
        };
        
        // Clear all classes
        elements.systemStatusIcon.className = 'status-icon';
        // Add appropriate class
        elements.systemStatusIcon.classList.add(statusClasses[status] || 'warning');
        
        elements.systemStatusText.textContent = message || 'System status unknown';
    }

    // Update the stats display
    function updateStats() {
        elements.totalPredictions.textContent = state.predictionHistory.length;
        elements.currentStreak.textContent = state.currentStreak;
        
        if (state.predictionHistory.length > 0) {
            const correctPredictions = state.predictionHistory.filter(entry => entry.result === '🏆').length;
            const accuracy = Math.round((correctPredictions / state.predictionHistory.length) * 100);
            elements.accuracyRate.textContent = `${accuracy}%`;
            
            if (state.predictionHistory[0]) {
                elements.lastResult.textContent = state.predictionHistory[0].result;
            }
        } else {
            elements.accuracyRate.textContent = '0%';
            elements.lastResult.textContent = '--';
        }
    }

    // Update pattern analysis display
    function updatePatternAnalysis() {
        if (state.predictionHistory.length === 0) return;
        
        // Track patterns for visualization
        const recentResults = state.predictionHistory.slice(0, 20);
        const smallCount = recentResults.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = recentResults.filter(entry => entry.actualNumber >= 5).length;
        const total = smallCount + bigCount;
        
        const smallPercent = Math.round((smallCount / total) * 100);
        const bigPercent = Math.round((bigCount / total) * 100);
        
        elements.smallPatternBar.style.width = `${smallPercent}%`;
        elements.smallPatternBar.textContent = smallPercent >= 10 ? `Small ${smallPercent}%` : '';
        elements.bigPatternBar.style.width = `${bigPercent}%`;
        elements.bigPatternBar.textContent = bigPercent >= 10 ? `Big ${bigPercent}%` : '';
        
        // Update pattern indicator
        if (smallPercent > 60) {
            elements.patternIndicator.textContent = 'SMALL ▲';
            elements.patternIndicator.className = 'prediction-value trend-up';
            elements.patternStrength.textContent = `Strength: ${smallPercent}%`;
        } else if (bigPercent > 60) {
            elements.patternIndicator.textContent = 'BIG ▲';
            elements.patternIndicator.className = 'prediction-value trend-up';
            elements.patternStrength.textContent = `Strength: ${bigPercent}%`;
        } else {
            elements.patternIndicator.textContent = 'Mixed ➝';
            elements.patternIndicator.className = 'prediction-value trend-neutral';
            elements.patternStrength.textContent = 'Strength: Balanced';
        }
        
        // Save pattern for trend analysis
        if (state.patternHistory.length >= 5) {
            state.patternHistory.shift();
        }
        state.patternHistory.push(smallPercent);
    }

    // Update trend analysis display
    function updateTrendAnalysis() {
        if (state.patternHistory.length < 3) {
            elements.trendIndicator.textContent = '--';
            elements.trendStrength.textContent = 'Momentum: --';
            elements.trendDuration.textContent = 'Duration: --';
            return;
        }
        
        // Calculate trend direction and momentum
        const trendDirection = state.patternHistory[0] < state.patternHistory[state.patternHistory.length - 1] ? 'Up' : 'Down';
        const trendMomentum = Math.abs(state.patternHistory[0] - state.patternHistory[state.patternHistory.length - 1]);
        
        // Determine trend duration
        let duration = 'Short-term';
        if (state.patternHistory.length >= 5) {
            const consistentTrend = state.patternHistory.every((val, i, arr) => 
                i === 0 || (trendDirection === 'Up' ? val >= arr[i-1] : val <= arr[i-1]));
            if (consistentTrend) {
                duration = 'Long-term';
            }
        }
        
        // Update UI
        if (trendDirection === 'Up') {
            elements.trendIndicator.textContent = 'SMALL ▲';
            elements.trendIndicator.className = 'prediction-value trend-up';
        } else {
            elements.trendIndicator.textContent = 'BIG ▲';
            elements.trendIndicator.className = 'prediction-value trend-up';
        }
        
        elements.trendStrength.textContent = `Momentum: ${trendMomentum.toFixed(1)}%`;
        elements.trendDuration.textContent = `Duration: ${duration}`;
    }

    // Update heatmap display
    function updateHeatMap() {
        // Find max count for normalization
        const maxCount = Math.max(...state.heatMapNumbers);
        
        // Update heatmap cells
        for (let i = 0; i < 10; i++) {
            const cell = document.getElementById(`heat-cell-${i}`);
            if (!cell) continue;
            
            const count = state.heatMapNumbers[i];
            cell.setAttribute('data-count', count);
            const intensity = maxCount > 0 ? (count / maxCount) : 0;
            
            // Set color based on intensity
            if (intensity > 0.7) {
                cell.style.backgroundColor = `rgba(255, 50, 50, ${0.3 + intensity * 0.7})`;
            } else if (intensity > 0.4) {
                cell.style.backgroundColor = `rgba(255, 165, 0, ${0.3 + intensity * 0.7})`;
            } else {
                cell.style.backgroundColor = `rgba(0, 240, 255, ${0.1 + intensity * 0.7})`;
            }
        }
    }

    // Update the prediction history table
    function updatePredictionHistoryTable() {
        elements.historyTableBody.innerHTML = '';
        
        if (state.predictionHistory.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="5">No prediction history available</td>';
            elements.historyTableBody.appendChild(row);
            return;
        }

        const start = state.currentPage * state.itemsPerPage;
        const end = start + state.itemsPerPage;
        const paginatedHistory = state.predictionHistory.slice(start, end);

        paginatedHistory.forEach(entry => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${entry.issueNumber}</td>
                <td>${entry.predictedNumber} (${entry.predictedCategory})</td>
                <td>${entry.actualNumber} (${entry.actualCategory})</td>
                <td style="color: ${entry.result === '🏆' ? 'var(--matrix-green)' : 'var(--error-red)'}">${entry.result}</td>
                <td>${new Date(entry.timestamp).toLocaleTimeString()}</td>
            `;
            elements.historyTableBody.appendChild(row);
        });

        // Update pagination buttons
        elements.prevPageButton.disabled = state.currentPage === 0 || state.predictionHistory.length === 0;
        elements.nextPageButton.disabled = end >= state.predictionHistory.length || state.predictionHistory.length === 0;
    }

    // Generate a new prediction
    function generatePrediction() {
        let prediction;
        
        switch(state.settings.algorithmType) {
            case 'basic':
                prediction = generateBasicPrediction();
                break;
            case 'quantum':
                prediction = generateQuantumPrediction();
                break;
            case 'hybrid':
                prediction = generateHybridPrediction();
                break;
            case 'advanced':
            default:
                prediction = generateAdvancedPrediction();
                break;
        }
        
        return prediction;
    }

    // Basic prediction algorithm (simple random)
    function generateBasicPrediction() {
        const predictedNumber = Math.floor(Math.random() * 10);
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.floor(Math.random() * 30) + 50 // 50-80%
        };
    }

    // Advanced prediction algorithm (history-based)
    function generateAdvancedPrediction() {
        if (state.predictionHistory.length === 0) {
            return generateBasicPrediction();
        }
        
        const smallCount = state.predictionHistory.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = state.predictionHistory.filter(entry => entry.actualNumber >= 5).length;
        
        const total = smallCount + bigCount;
        const smallProbability = total ? (smallCount / total) : 0.5;
        
        // Add weighted randomness based on settings
        const randomFactor = (Math.random() * state.settings.randomnessFactor / 50) - (state.settings.randomnessFactor / 100);
        const adjustedProbability = Math.max(0.1, Math.min(0.9, smallProbability + randomFactor));
        
        // Generate number with weighted probability
        const predictedNumber = Math.random() < adjustedProbability ? 
            Math.floor(Math.random() * 5) : // Small number (0-4)
            Math.floor(Math.random() * 5) + 5; // Big number (5-9)
            
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.round(adjustedProbability * 100)
        };
    }

    // Quantum simulation prediction (more complex pattern recognition)
    function generateQuantumPrediction() {
        if (state.predictionHistory.length < 5) {
            return generateAdvancedPrediction();
        }
        
        // Analyze recent patterns
        const recentResults = state.predictionHistory.slice(0, 10);
        const smallCount = recentResults.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = recentResults.filter(entry => entry.actualNumber >= 5).length;
        
        // Calculate probabilities with momentum
        const smallProbability = (smallCount / recentResults.length) * 1.2; // Slight bias towards continuing trend
        const bigProbability = (bigCount / recentResults.length) * 1.2;
        
        // Normalize probabilities
        const total = smallProbability + bigProbability;
        const normalizedSmall = smallProbability / total;
        
        // Add randomness based on settings
        const randomFactor = (Math.random() * state.settings.randomnessFactor / 100) - (state.settings.randomnessFactor / 200);
        const adjustedProbability = Math.max(0.1, Math.min(0.9, normalizedSmall + randomFactor));
        
        // Generate prediction
        const predictedNumber = Math.random() < adjustedProbability ? 
            Math.floor(Math.random() * 5) : // Small number (0-4)
            Math.floor(Math.random() * 5) + 5; // Big number (5-9)
            
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.round(adjustedProbability * 100)
        };
    }

    // Hybrid prediction algorithm (combines multiple approaches)
    function generateHybridPrediction() {
        const basicPred = generateBasicPrediction();
        const advancedPred = generateAdvancedPrediction();
        const quantumPred = generateQuantumPrediction();
        
        // Weighted average based on history weight setting
        const historyWeight = state.settings.historyWeight / 100;
        const confidence = Math.round(
            (quantumPred.confidence * historyWeight) + 
            (advancedPred.confidence * (1 - historyWeight) * 0.7) + 
            (basicPred.confidence * (1 - historyWeight) * 0.3)
        );
        
        // Decide which prediction to use based on confidence
        if (quantumPred.confidence >= 70) {
            return { ...quantumPred, confidence };
        } else if (advancedPred.confidence >= 60) {
            return { ...advancedPred, confidence };
        } else {
            return { ...basicPred, confidence };
        }
    }

    // Categorize numbers as Small (0-4) or Big (5-9)
    function categorizeNumber(number) {
        return (number >= 0 && number <= 4) ? 'BIG':'SMALL';
        return (number >= 5 && number <= 9) ? 'SNALL':'BIG';
    }

    // API fetch functions with error handling
    async function fetchNoAverageEmerdList() {
        try {
            const requestData = {
                pageSize: 10,
                pageNo: 1,
                typeId: 1,
                language: 0,
                random: "ded40537a2ce416e96c00e5218f6859a",
                signature: "69306982EEEB19FA940D72EC93C62552",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching no average EMERD list:', error);
            throw error;
        }
    }

    async function fetchGameIssue() {
        try {
            const requestData = {
                typeId: 1,
                language: 0,
                random: "f8dcb5c527814db68800e3946a2b60e8",
                signature: "08CF7FF3339ED58D4743F4B650FCBEA9",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetGameIssue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching game issue:', error);
            throw error;
        }
    }

    // Message display functions
    function clearMessages() {
        elements.errorMessage.textContent = '';
        elements.warningMessage.textContent = '';
        elements.successMessage.textContent = '';
        elements.infoMessage.textContent = '';
    }

    function showError(message) {
        elements.errorMessage.textContent = message;
        console.error(message);
        addNotification('System Error', message, 'error');
    }

    function showWarning(message) {
        elements.warningMessage.textContent = message;
        console.warn(message);
        setTimeout(() => elements.warningMessage.textContent = '', 5000);
        addNotification('System Warning', message, 'warning');
    }

    function showSuccess(message) {
        elements.successMessage.textContent = message;
        console.log(message);
        setTimeout(() => elements.successMessage.textContent = '', 5000);
        addNotification('System Update', message, 'success');
    }

    function showInfo(message) {
        elements.infoMessage.textContent = message;
        console.log(message);
        setTimeout(() => elements.infoMessage.textContent = '', 5000);
        addNotification('System Info', message, 'info');
    }

    // Notification system
    function addNotification(title, message, type) {
        // Check notification frequency setting
        if (state.settings.notificationFrequency === 'none' || 
            (state.settings.notificationFrequency === 'important' && type === 'info')) {
            return;
        }

        const newNotification = {
            id: Date.now(),
            title,
            message,
            type,
            timestamp: new Date().toISOString(),
            read: false
        };
        
        state.notifications.unshift(newNotification);
        
        // Keep only the last 20 notifications
        if (state.notifications.length > 20) {
            state.notifications = state.notifications.slice(0, 20);
        }
        
        // Save to localStorage
        localStorage.setItem('notifications', JSON.stringify(state.notifications));
        
        // Update UI
        updateNotificationBadge();
        
        // Play sound if enabled
        if (state.settings.sound) {
            playNotificationSound(type);
        }
        
        // Vibrate if enabled
        if (state.settings.vibration && navigator.vibrate) {
            navigator.vibrate(type === 'error' ? [200, 100, 200] : [200]);
        }
    }

    function playNotificationSound(type) {
        // In a real app, you would play actual sounds here
        console.log(`Playing ${type} notification sound`);
    }

    function updateNotificationBadge() {
        const unreadCount = state.notifications.filter(n => !n.read).length;
        elements.notificationBadge.textContent = unreadCount;
        elements.notificationBadge.style.display = unreadCount > 0 ? 'flex' : 'none';
    }

    function updateNotificationList() {
        elements.notificationList.innerHTML = '';
        
        if (state.notifications.length === 0) {
            elements.notificationList.innerHTML = '<div class="notification-item">No notifications</div>';
            return;
        }
        
        state.notifications.forEach(notification => {
            const item = document.createElement('div');
            item.className = `notification-item ${notification.type}`;
            item.innerHTML = `
                <div class="notification-title">
                    <i class="fas fa-${getNotificationIcon(notification.type)}"></i>
                    ${notification.title}
                </div>
                <div class="notification-message">${notification.message}</div>
                <div class="notification-time">${new Date(notification.timestamp).toLocaleTimeString()}</div>
            `;
            elements.notificationList.appendChild(item);
        });
        
        // Mark all as read when panel is opened
        state.notifications.forEach(n => n.read = true);
        localStorage.setItem('notifications', JSON.stringify(state.notifications));
        updateNotificationBadge();
    }

    function getNotificationIcon(type) {
        switch(type) {
            case 'error': return 'exclamation-circle';
            case 'warning': return 'exclamation-triangle';
            case 'success': return 'check-circle';
            case 'info': 
            default: return 'info-circle';
        }
    }

    // Export data as CSV
    function exportData() {
        if (state.predictionHistory.length === 0) {
            showWarning('No data available to export');
            return;
        }
        
        // Prepare CSV content
        let csvContent = "Issue,Predicted Number,Predicted Category,Actual Number,Actual Category,Result,Timestamp\n";
        
        state.predictionHistory.forEach(entry => {
            csvContent += `"${entry.issueNumber}","${entry.predictedNumber}","${entry.predictedCategory}","${entry.actualNumber}","${entry.actualCategory}","${entry.result}","${entry.timestamp}"\n`;
        });
        
        // Create download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `quantum_ai_predictions_${new Date().toISOString().slice(0, 10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showSuccess('Data exported successfully');
    }

    // Event listeners
    elements.prevPageButton.addEventListener('click', () => {
        if (state.currentPage > 0) {
            state.currentPage--;
            updatePredictionHistoryTable();
        }
    });

    elements.nextPageButton.addEventListener('click', () => {
        if ((state.currentPage + 1) * state.itemsPerPage < state.predictionHistory.length) {
            state.currentPage++;
            updatePredictionHistoryTable();
        }
    });

    elements.notificationBell.addEventListener('click', () => {
        elements.notificationPanel.style.display = elements.notificationPanel.style.display === 'block' ? 'none' : 'block';
        if (elements.notificationPanel.style.display === 'block') {
            updateNotificationList();
        }
    });

    elements.settingsButton.addEventListener('click', () => {
        elements.settingsPanel.style.display = 'block';
    });

    elements.settingsClose.addEventListener('click', () => {
        elements.settingsPanel.style.display = 'none';
    });

    elements.saveSettingsButton.addEventListener('click', () => {
        // Save settings
        state.settings = {
            algorithmType: document.getElementById('algorithmType').value,
            randomnessFactor: parseInt(document.getElementById('randomnessFactor').value),
            historyWeight: parseInt(document.getElementById('historyWeight').value),
            theme: document.getElementById('themeSelect').value,
            animations: document.getElementById('animationsToggle').checked,
            darkMode: document.getElementById('darkModeToggle').checked,
            sound: document.getElementById('soundToggle').checked,
            vibration: document.getElementById('vibrationToggle').checked,
            notificationFrequency: document.getElementById('notificationFrequency').value
        };
        
        localStorage.setItem('systemSettings', JSON.stringify(state.settings));
        elements.settingsPanel.style.display = 'none';
        showSuccess('Settings saved successfully');
        
        // Apply theme changes
        applyTheme();
    });

    document.getElementById('randomnessFactor').addEventListener('input', (e) => {
        document.getElementById('randomnessValue').textContent = e.target.value + '%';
    });

    document.getElementById('historyWeight').addEventListener('input', (e) => {
        document.getElementById('historyWeightValue').textContent = e.target.value + '%';
    });

    elements.manualRefreshButton.addEventListener('click', () => {
        updateData();
    });

    elements.exportDataButton.addEventListener('click', () => {
        exportData();
    });

    elements.advancedAnalysisButton.addEventListener('click', () => {
        showInfo('Advanced analysis feature coming in next update!');
    });

    // Close notifications when clicking outside
    document.addEventListener('click', (event) => {
        if (!elements.notificationBell.contains(event.target) && !elements.notificationPanel.contains(event.target)) {
            elements.notificationPanel.style.display = 'none';
        }
        
        if (!elements.settingsButton.contains(event.target) && !elements.settingsPanel.contains(event.target) && 
            event.target !== elements.settingsPanel && !elements.settingsClose.contains(event.target)) {
            elements.settingsPanel.style.display = 'none';
        }
    });

    // Apply theme settings
    function applyTheme() {
        // In a real app, you would implement theme switching here
        console.log('Applying theme:', state.settings.theme);
    }

    // Initialize the application
    init();
});
</script>
</body>
</html>
