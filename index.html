       <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI PREDICTION SYSTEM - SURYA S3 ULTRA</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Exo+2:wght@400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --ai-purple: #7d00ff;
            --matrix-green: #00ff00;
            --error-red: #ff0033;
            --warning-yellow: #ffcc00;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: radial-gradient(circle at center, #0a0a2e, #000000);
            color: #ffffff;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1, h2 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            text-align: center;
            background: linear-gradient(45deg, var(--neon-blue), var(--ai-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
            margin-bottom: 1.5rem;
        }

        .card {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem auto;
            max-width: 90%;
            backdrop-filter: blur(10px);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 14px;
            background: linear-gradient(45deg, var(--neon-blue), var(--ai-purple), var(--matrix-green));
            z-index: -1;
            opacity: 0.3;
        }

        #timeRemaining {
            font-size: 2.5em;
            font-family: 'Orbitron', sans-serif;
            color: var(--matrix-green);
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            text-align: center;
            margin: 0.5rem 0;
        }

        .prediction-display {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .prediction-box {
            flex: 1;
            min-width: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .prediction-value {
            font-size: 2rem;
            font-family: 'Orbitron', sans-serif;
            margin: 0.5rem 0;
        }

        .prediction-label {
            color: var(--neon-blue);
            font-size: 0.9rem;
        }

        .status-message {
            text-align: center;
            margin: 1rem 0;
            font-style: italic;
        }

        .error-message {
            color: var(--error-red);
            text-align: center;
            margin: 1rem 0;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .warning-message {
            color: var(--warning-yellow);
            text-align: center;
            margin: 1rem 0;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        /* Responsive Table Styling */
        .table-container {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 100px;
            border-radius: 1px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.5);
        }

        th, td {
            padding: 1rem;
            border: 1px solid rgba(0, 243, 255, 0.2);
            text-align: center;
        }

        th {
            background: linear-gradient(45deg, var(--ai-purple), var(--neon-blue));
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: rgba(0, 243, 255, 0.05);
        }

        /* Buttons */
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .neon-button {
            background: linear-gradient(45deg, var(--ai-purple), var(--neon-blue));
            border: none;
            padding: 1rem 2rem;
            border-radius: 9px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            position: relative;
            overflow: hidden;
        }

        .neon-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 20%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0.3),
                rgba(255, 255, 255, 0)
            );
            transform: rotate(30deg);
        }

        .neon-button:hover {
            box-shadow: 0 0 25px var(--neon-blue);
            transform: translateY(-2px);
        }

        .neon-button:active {
            transform: translateY(0);
        }

        .neon-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 243, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--neon-blue);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stats display */
        .stats-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            margin: 0.5rem 0;
            color: var(--neon-blue);
        }

        .stat-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .prediction-display, .stats-container {
                flex-direction: column;
            }
            
            .prediction-box, .stat-box {
                min-width: %;
            }
            
            th, td {
                padding: 0.7rem;
                font-size: 0.9rem;
            }
            
            .neon-button {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
                min-width: 120px;
            }
            
            #timeRemaining {
                font-size: 1.8em;
            }
            
            .prediction-value {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <h1>SURYA AI S3 CHARTGPT</h1>
    <p class="status-message">Quantum Neural Network Prediction System - Version 3.2.1</p>

    <div class="card">
        <h2>Neural Network Prediction</h2>
        <div id="loadingSpinner" class="spinner" style="display: none;"></div>
        <div id="errorMessage" class="error-message"></div>
        <div id="warningMessage" class="warning-message"></div>
        
        <div class="prediction-display">
            <div class="prediction-box">
                <div class="prediction-label">CURRENT PREDICTION</div>
                <div id="predictedNumber" class="prediction-value">--</div>
                <div id="predictionCategory" class="prediction-label">Category: --</div>
            </div>
            
            <div class="prediction-box">
                <div class="prediction-label">CONFIDENCE LEVEL</div>
                <div id="predictedPremium" class="prediction-value">--%</div>
                <div class="prediction-label">Based on historical patterns</div>
            </div>
        </div>
        
        <p id="timeRemaining">SYNCING WITH QUANTUM NETWORK...</p>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">TOTAL PREDICTIONS</div>
                <div id="totalPredictions" class="stat-value">0</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-label">ACCURACY RATE</div>
                <div id="accuracyRate" class="stat-value">0%</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-label">LAST RESULT</div>
                <div id="lastResult" class="stat-value">--</div>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>Quantum Data Interface</h2>
        <div class="table-container">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Number</th>
                        <th>Pattern</th>
                        <th>Probability</th>
                        <th>Timestamp</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <h2>Prediction Matrix</h2>
        <div class="table-container">
            <table id="predictionHistoryTable">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Predicted</th>
                        <th>Actual</th>
                        <th>Result</th>
                        <th>Timestamp</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="button-group">
            <button id="prevPage" class="neon-button" disabled>◄ Previous</button>
            <button id="nextPage" class="neon-button" disabled>Next ►</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const tableBody = document.querySelector('#dataTable tbody');
    const predictedNumberElement = document.getElementById('predictedNumber');
    const predictionCategoryElement = document.getElementById('predictionCategory');
    const predictedPremiumElement = document.getElementById('predictedPremium');
    const timerElement = document.getElementById('timeRemaining');
    const historyTableBody = document.querySelector('#predictionHistoryTable tbody');
    const prevPageButton = document.getElementById('prevPage');
    const nextPageButton = document.getElementById('nextPage');
    const errorMessageElement = document.getElementById('errorMessage');
    const warningMessageElement = document.getElementById('warningMessage');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const totalPredictionsElement = document.getElementById('totalPredictions');
    const accuracyRateElement = document.getElementById('accuracyRate');
    const lastResultElement = document.getElementById('lastResult');

    // Data state
    let predictionHistory = [];
    let lastPrediction = null;
    let currentPrediction = null;
    let currentPage = 0;
    const itemsPerPage = 10;
    let timerInterval = null;
    let isFetching = false;
    let systemStatus = 'initializing';

    // Initialize the app
    function init() {
        try {
            // Show loading state
            systemStatus = 'loading';
            updateSystemStatus();
            loadingSpinner.style.display = 'block';

            // Load saved data from localStorage
            const savedHistory = localStorage.getItem('predictionHistory');
            predictionHistory = savedHistory ? JSON.parse(savedHistory) : [];
            
            lastPrediction = JSON.parse(localStorage.getItem('lastPrediction'));
            currentPrediction = JSON.parse(localStorage.getItem('currentPrediction'));

            // Update stats
            updateStats();

            // Update UI with initial data
            updatePredictionHistoryTable();
            updateUI();

            // Start the update cycle
            startUpdateCycle();
        } catch (error) {
            showError('System initialization failed: ' + error.message);
            console.error('Initialization error:', error);
        } finally {
            loadingSpinner.style.display = 'none';
        }
    }

    // Start the periodic update cycle
    function startUpdateCycle() {
        // Clear any existing interval
        if (timerInterval) {
            clearInterval(timerInterval);
        }

        // Immediate update
        updateData();

        // Set up periodic updates (every 10 seconds)
        timerInterval = setInterval(updateData);
    }

    // Main update function
    async function updateData() {
        if (isFetching) return;
        isFetching = true;
        systemStatus = 'updating';
        updateSystemStatus();
        loadingSpinner.style.display = 'block';
        errorMessageElement.textContent = '';

        try {
            // Fetch the latest data
            const [emerData, gameIssueData] = await Promise.all([
                fetchNoAverageEmerdList(),
                fetchGameIssue()
            ]);

            // Process the data
            if (emerData && emerData.data && emerData.data.list && emerData.data.list.length > 0) {
                updateDataTable(emerData.data.list);
                processNewData(emerData.data.list);
            } else {
                showWarning('No new data available from quantum interface');
            }

            if (gameIssueData && gameIssueData.data) {
                updateTimer(gameIssueData.data.endTime);
            } else {
                showWarning('Could not sync with time server');
            }

            updateUI();
            systemStatus = 'operational';
            updateSystemStatus();
        } catch (error) {
            systemStatus = 'error';
            updateSystemStatus();
            showError('Data synchronization failed: ' + error.message);
            console.error('Update error:', error);
        } finally {
            isFetching = false;
            loadingSpinner.style.display = 'none';
        }
    }

    // Update the data table with new results
    function updateDataTable(dataList) {
        tableBody.innerHTML = '';
        dataList.forEach(item => {
            const numberCategory = categorizeNumber(Number(item.number));
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.issueNumber}</td>
                <td>${item.number} (${numberCategory})</td>
                <td>${item.colour || '--'}</td>
                <td>${item.premium || '--'}</td>
                <td>${new Date().toLocaleTimeString()}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    // Process new data and update predictions
    function processNewData(dataList) {
        const latestItem = dataList[0];
        const latestIssue = latestItem.issueNumber;
        const latestActual = Number(latestItem.number);
        const actualCategory = categorizeNumber(latestActual);

        // Check if we have a new issue
        if (!lastPrediction || lastPrediction.issueNumber !== latestIssue) {
            // If we had a previous prediction, record its accuracy
            if (lastPrediction) {
                const isCorrect = lastPrediction.category === actualCategory;
                const newHistoryEntry = {
                    issueNumber: latestIssue,
                    predictedNumber: lastPrediction.number,
                    predictedCategory: lastPrediction.category,
                    actualNumber: latestActual,
                    actualCategory: actualCategory,
                    result: isCorrect ? '🏆' : '✗',
                    timestamp: new Date().toISOString()
                };

                predictionHistory.unshift(newHistoryEntry);
                
                // Keep only the last 100 entries to prevent memory issues
                if (predictionHistory.length > 100) {
                    predictionHistory = predictionHistory.slice(0, 100);
                }

                localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));
                updateStats();
            }

            // Generate a new prediction
            currentPrediction = generatePrediction();
            currentPrediction.issueNumber = latestIssue;
            localStorage.setItem('currentPrediction', JSON.stringify(currentPrediction));

            // Update last prediction reference
            lastPrediction = {
                issueNumber: latestIssue,
                number: currentPrediction.number,
                category: currentPrediction.category
            };
            localStorage.setItem('lastPrediction', JSON.stringify(lastPrediction));
        }
    }

    // Update the timer display
    function updateTimer(endTime) {
        const endDate = new Date(endTime);
        const now = new Date();
        const remainingTimeMs = endDate - now;

        if (remainingTimeMs <= 0) {
            timerElement.textContent = "00:00:00";
            // Trigger an immediate update when time runs out
            setTimeout(updateData, 500);
        } else {
            const hours = String(Math.floor(remainingTimeMs / 3600000)).padStart(2, '0');
            const minutes = String(Math.floor((remainingTimeMs % 3600000) / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((remainingTimeMs % 60000) / 1000)).padStart(2, '0');
            timerElement.textContent = `${hours}:${minutes}:${seconds}`;
        }
    }

    // Update the UI with current data
    function updateUI() {
        // Update prediction display
        if (currentPrediction) {
            predictedNumberElement.textContent = currentPrediction.number;
            predictionCategoryElement.textContent = `Category: ${currentPrediction.category}`;
            predictedPremiumElement.textContent = `${currentPrediction.confidence}%`;
        } else {
            predictedNumberElement.textContent = '--';
            predictionCategoryElement.textContent = 'BUY STOCK: --';
            predictedPremiumElement.textContent = '--%';
        }

        // Update history table
        updatePredictionHistoryTable();
    }

    // Update system status display
    function updateSystemStatus() {
        const statusMessages = {
            'initializing': 'Initializing quantum neural network...',
            'loading': 'Loading historical data patterns...',
            'updating': 'Synchronizing with quantum interface...',
            'operational': 'System operational - predictions active',
            'error': 'System error detected - attempting recovery'
        };
        
        const statusElement = document.querySelector('.status-message');
        if (statusElement) {
            statusElement.textContent = statusMessages[systemStatus] || 'System status unknown';
        }
    }

    // Update the stats display
    function updateStats() {
        totalPredictionsElement.textContent = predictionHistory.length;
        
        if (predictionHistory.length > 0) {
            const correctPredictions = predictionHistory.filter(entry => entry.result === '🏆').length;
            const accuracy = Math.round((correctPredictions / predictionHistory.length) * 100);
            accuracyRateElement.textContent = `${accuracy}%`;
            
            if (predictionHistory[0]) {
                lastResultElement.textContent = predictionHistory[0].result;
                lastResultElement.style.color = predictionHistory[0].result === '🏆' ? 'var(--matrix-green)' : 'var(--error-red)';
            }
        } else {
            accuracyRateElement.textContent = '0%';
            lastResultElement.textContent = '--';
        }
    }

    // Update the prediction history table
    function updatePredictionHistoryTable() {
        historyTableBody.innerHTML = '';
        
        if (predictionHistory.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="5">No prediction history available</td>';
            historyTableBody.appendChild(row);
            return;
        }

        const start = currentPage * itemsPerPage;
        const end = start + itemsPerPage;
        const paginatedHistory = predictionHistory.slice(start, end);

        paginatedHistory.forEach(entry => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${entry.issueNumber}</td>
                <td>${entry.predictedNumber} (${entry.predictedCategory})</td>
                <td>${entry.actualNumber} (${entry.actualCategory})</td>
                <td style="color: ${entry.result === '𝐖𝐈𝐍' ? 'var(--matrix-green)' : 'var(--error-red)'}">${entry.result}</td>
                <td>${new Date(entry.timestamp).toLocaleTimeString()}</td>
            `;
            historyTableBody.appendChild(row);
        });

        // Update pagination buttons
        prevPageButton.disabled = currentPage === 0 || predictionHistory.length === 0;
        nextPageButton.disabled = end >= predictionHistory.length || predictionHistory.length === 0;
    }

    // Generate a new prediction
    function generatePrediction() {
        // Enhanced prediction algorithm
        const smallCount = predictionHistory.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = predictionHistory.filter(entry => entry.actualNumber >= 5).length;
        
        const total = smallCount + bigCount;
        const smallProbability = total ? (smallCount / total) : 0.5;
        
        // Add weighted randomness based on history
        const randomFactor = Math.random() * 0.3 - 0.15; // ±15% randomness
        const adjustedProbability = Math.max(0.1, Math.min(0.9, smallProbability + randomFactor));
        
        // Generate number with weighted probability
        const predictedNumber = Math.random() < adjustedProbability ? 
            Math.floor(Math.random() * 5) : // Small number (0-4)
            Math.floor(Math.random() * 5) + 5; // Big number (5-9)
            
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.round(adjustedProbability * 100)
        };
    }

    // Categorize numbers as Small (0-4) or Big (5-9)
    function categorizeNumber(number) {
        return (number >= 0 && number <= 4) ? 'Small' : 'Big';
    }

    // API fetch functions with error handling
    async function fetchNoAverageEmerdList() {
        try {
            const requestData = {
                pageSize: 10,
                pageNo: 1,
                typeId: 1,
                language: 0,
                random: "ded40537a2ce416e96c00e5218f6859a",
                signature: "69306982EEEB19FA940D72EC93C62552",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching no average EMERD list:', error);
            throw error;
        }
    }

    async function fetchGameIssue() {
        try {
            const requestData = {
                typeId: 1,
                language: 0,
                random: "f8dcb5c527814db68800e3946a2b60e8",
                signature: "08CF7FF3339ED58D4743F4B650FCBEA9",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetGameIssue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching game issue:', error);
            throw error;
        }
    }

    // Show error message
    function showError(message) {
        errorMessageElement.textContent = message;
        console.error(message);
    }

    // Show warning message
    function showWarning(message) {
        warningMessageElement.textContent = message;
        console.warn(message);
        setTimeout(() => warningMessageElement.textContent = '', 5000);
    }

    // Event listeners
    prevPageButton.addEventListener('click', () => {
        if (currentPage > 0) {
            currentPage--;
            updatePredictionHistoryTable();
        }
    });

    nextPageButton.addEventListener('click', () => {
        if ((currentPage + 1) * itemsPerPage < predictionHistory.length) {
            currentPage++;
            updatePredictionHistoryTable();
        }
    });

    // Initialize the application
    init();
});
</script>
</body>
</html>                 
                
