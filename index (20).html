<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI PREDICTION SYSTEM - SURYA S3 ULTRA PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Exo+2:wght@400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --ai-purple: #7d00ff;
            --matrix-green: #00ff00;
            --error-red: #ff0033;
            --warning-yellow: #ffcc00;
            --success-green: #00ff88;
            --info-blue: #0099ff;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: radial-gradient(circle at center, #0a0a2e, #000000);
            color: #ffffff;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1, h2 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            text-align: center;
            background: linear-gradient(45deg, var(--neon-blue), var(--ai-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
            margin-bottom: 1.5rem;
        }

        .card {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem auto;
            max-width: 90%;
            backdrop-filter: blur(10px);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 14px;
            background: linear-gradient(45deg, var(--neon-blue), var(--ai-purple), var(--matrix-green));
            z-index: -1;
            opacity: 0.3;
        }

        #timeRemaining {
            font-size: 2.5em;
            font-family: 'Orbitron', sans-serif;
            color: var(--matrix-green);
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            text-align: center;
            margin: 0.5rem 0;
        }

        .prediction-display {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .prediction-box {
            flex: 1;
            min-width: 1px;
            background: rgba(0, 0, 0, 0.5);
            border: 10px solid rgba(0, 243, 255, 0.2);
            border-radius: 800px;
            padding: 1rem;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .prediction-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 243, 255, 0.3);
        }

        .prediction-value {
            font-size: 2rem;
            font-family: 'Orbitron', sans-serif;
            margin: 0.5rem 0;
        }

        .prediction-label {
            color: var(--neon-blue);
            font-size: 0.9rem;
        }

        .status-message {
            text-align: center;
            margin: 1rem 0;
            font-style: italic;
        }

        .error-message {
            color: var(--error-red);
            text-align: center;
            margin: 1rem 0;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .warning-message {
            color: var(--warning-yellow);
            text-align: center;
            margin: 1rem 0;
        }

        .success-message {
            color: var(--success-green);
            text-align: center;
            margin: 1rem 0;
        }

        .info-message {
            color: var(--info-blue);
            text-align: center;
            margin: 1rem 0;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        /* Responsive Table Styling */
        .table-container {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 100px;
            border-radius: 1px;
        }

        table {
            width: 10%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.5);
        }

        th, td {
            padding: 1rem;
            border: 1px solid rgba(0, 243, 255, 0.2);
            text-align: center;
        }

        th {
            background: linear-gradient(45deg, var(--ai-purple), var(--neon-blue));
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: rgba(0, 243, 255, 0.05);
        }

        /* Buttons */
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .neon-button {
            background: linear-gradient(45deg, var(--ai-purple), var(--neon-blue));
            border: none;
            padding: 1rem 2rem;
            border-radius: 9px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            position: relative;
            overflow: hidden;
        }

        .neon-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 20%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0.3),
                rgba(255, 255, 255, 0)
            );
            transform: rotate(30deg);
        }

        .neon-button:hover {
            box-shadow: 0 0 25px var(--neon-blue);
            transform: translateY(-2px);
        }

        .neon-button:active {
            transform: translateY(0);
        }

        .neon-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 243, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--neon-blue);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stats display */
        .stats-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        .stat-value {
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            margin: 0.5rem 0;
            color: var(--neon-blue);
        }

        .stat-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        /* New Features */
        .pattern-analysis {
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid var(--ai-purple);
        }

        .pattern-analysis h3 {
            color: var(--neon-blue);
            margin-top: 0;
        }

        .pattern-bars {
            display: flex;
            height: 30px;
            margin: 1rem 0;
            border-radius: 4px;
            overflow: hidden;
        }

        .pattern-bar {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            transition: width 0.5s ease;
        }

        .pattern-bar.small {
            background-color: rgba(0, 243, 255, 0.7);
        }

        .pattern-bar.big {
            background-color: rgba(125, 0, 255, 0.7);
        }

        .trend-indicator {
            display: inline-block;
            margin-left: 110.5rem;
            font-size: 1.2rem;
        }

        .trend-up {
            color: var(--success-green);
        }

        .trend-down {
            color: var(--error-red);
        }

        .trend-neutral {
            color: var(--warning-yellow);
        }

        .heat-map {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 5px;
            margin: 1rem 0;
        }

        .heat-cell {
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .heat-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .notification-bell {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }

        .notification-bell i {
            color: var(--neon-blue);
            font-size: 1.5rem;
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--error-red);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .notification-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--neon-blue);
            border-radius: 8px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding: 1rem;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            display: none;
        }

        .notification-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
        }

        .notification-item:last-child {
            border-bottom: none;
        }

        .notification-time {
            font-size: 0.7rem;
            color: #aaa;
        }

        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--neon-blue);
            border-radius: 12px;
            padding: 2rem;
            z-index: 1001;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
            display: none;
        }

        .settings-panel h2 {
            margin-top: 0;
        }

        .settings-close {
            position: absolute;
            top: 15px;
            right: 15px;
            cursor: pointer;
            color: var(--neon-blue);
            font-size: 1.5rem;
        }

        .settings-group {
            margin-bottom: 1.5rem;
        }

        .settings-group h3 {
            color: var(--neon-blue);
            margin-bottom: 0.5rem;
        }

        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .settings-row label {
            flex: 1;
        }

        .settings-row select, .settings-row input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
        }

        .settings-row input[type="checkbox"] {
            width: auto;
        }

        .settings-save {
            margin-top: 1rem;
            text-align: center;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--neon-blue);
            font-size: 0.9rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .prediction-display, .stats-container {
                flex-direction: column;
            }
            
            .prediction-box, .stat-box {
                min-width: 10%;
            }
            
            th, td {
                padding: 0.7rem;
                font-size: 0.9rem;
            }
            
            .neon-button {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
                min-width: 120px;
            }
            
            #timeRemaining {
                font-size: 1.9em;
            }
            
            .prediction-value {
                font-size: 1.5rem;
            }

            .heat-map {
                grid-template-columns: repeat(5, 1fr);
            }

            .notification-panel {
                width: 259px;
                right: 10px;
            }

            .settings-panel {
                width: 90%;
                padding: 1rem;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="notification-bell" id="notificationBell">
        <i class="fas fa-bell"></i>
        <div class="notification-badge" id="notificationBadge">0</div>
    </div>
    <div class="notification-panel" id="notificationPanel">
        <h3>System Notifications</h3>
        <div id="notificationList"></div>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <span class="settings-close" id="settingsClose">&times;</span>
        <h2>System Settings</h2>
        
        <div class="settings-group">
            <h3>Prediction Algorithm</h3>
            <div class="settings-row">
                <label for="algorithmType">Algorithm Type:</label>
                <select id="algorithmType">
                    <option value="basic">Basic Pattern</option>
                    <option value="advanced" selected>Advanced AI</option>
                    <option value="quantum">Quantum Simulation</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="randomnessFactor">Randomness Factor:</label>
                <input type="range" id="randomnessFactor" min="0" max="100" value="15">
                <span id="randomnessValue">15%</span>
            </div>
        </div>
        
        <div class="settings-group">
            <h3>Display Options</h3>
            <div class="settings-row">
                <label for="themeSelect">Color Theme:</label>
                <select id="themeSelect">
                    <option value="default" selected>Default (Neon Blue)</option>
                    <option value="matrix">Matrix Green</option>
                    <option value="purple">Deep Purple</option>
                    <option value="red">Crimson Red</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="animationsToggle">Enable Animations:</label>
                <input type="checkbox" id="animationsToggle" checked>
            </div>
        </div>
        
        <div class="settings-group">
            <h3>Notifications</h3>
            <div class="settings-row">
                <label for="soundToggle">Enable Sound Alerts:</label>
                <input type="checkbox" id="soundToggle" checked>
            </div>
            <div class="settings-row">
                <label for="vibrationToggle">Enable Vibration:</label>
                <input type="checkbox" id="vibrationToggle">
            </div>
        </div>
        
        <div class="settings-save">
            <button class="neon-button" id="saveSettings">Save Settings</button>
        </div>
    </div>

    <h1>SURYA AI S3 ULTRA PRO</h1>
    <p class="status-message">Quantum Neural Network Prediction System - Version 4.0.0</p>

    <div class="card">
        <h2>Neural Network Prediction</h2>
        <div id="loadingSpinner" class="spinner" style="display: none;"></div>
        <div id="errorMessage" class="error-message"></div>
        <div id="warningMessage" class="warning-message"></div>
        <div id="successMessage" class="success-message"></div>
        <div id="infoMessage" class="info-message"></div>
        
        <div class="prediction-display">
            <div class="prediction-box">
                <div class="prediction-label">CURRENT PREDICTION</div>
                <div id="predictedNumber" class="prediction-value">--</div>
                <div id="predictionCategory" class="prediction-label">Category: --</div>
            </div>
            
            <div class="prediction-box">
                <div class="prediction-label">CONFIDENCE LEVEL</div>
                <div id="predictedPremium" class="prediction-value">--%</div>
                <div class="prediction-label">Based on historical patterns</div>
            </div>
            
            <div class="prediction-box">
                <div class="prediction-label">TREND ANALYSIS</div>
                <div id="trendIndicator" class="prediction-value">--</div>
                <div id="trendStrength" class="prediction-label">Strength: --</div>
            </div>
        </div>
        
        <p id="timeRemaining">SYNCING WITH QUANTUM NETWORK...</p>
        
        <div class="pattern-analysis">
            <h3>Pattern Analysis <span class="tooltip">ⓘ<span class="tooltiptext">Shows the distribution of small vs big numbers in recent results</span></span></h3>
            <div class="pattern-bars">
                <div class="pattern-bar small" id="smallBar" style="width: 50%">Small: 50%</div>
                <div class="pattern-bar big" id="bigBar" style="width: 50%">Big: 50%</div>
            </div>
        </div>
        
        <div class="pattern-analysis">
            <h3>Number Frequency Heatmap <span class="tooltip">ⓘ<span class="tooltiptext">Shows how often each number has appeared recently</span></span></h3>
            <div class="heat-map" id="heatMap">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">TOTAL PREDICTIONS</div>
                <div id="totalPredictions" class="stat-value">0</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-label">ACCURACY RATE</div>
                <div id="accuracyRate" class="stat-value">0%</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-label">STREAK</div>
                <div id="currentStreak" class="stat-value">0</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-label">LAST RESULT</div>
                <div id="lastResult" class="stat-value">--</div>
            </div>
        </div>
        
        <div class="button-group">
            <button id="manualRefresh" class="neon-button"><i class="fas fa-sync-alt"></i> Refresh Data</button>
            <button id="settingsButton" class="neon-button"><i class="fas fa-cog"></i> Settings</button>
            <button id="exportData" class="neon-button"><i class="fas fa-file-export"></i> Export</button>
        </div>
    </div>

    <div class="card">
        <h2>Quantum Data Interface</h2>
        <div class="table-container">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Number</th>
                        <th>Pattern</th>
                        <th>Probability</th>
                        <th>Timestamp</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <h2>Prediction Matrix</h2>
        <div class="table-container">
            <table id="predictionHistoryTable">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Predicted</th>
                        <th>Actual</th>
                        <th>Result</th>
                        <th>Timestamp</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="button-group">
            <button id="prevPage" class="neon-button" disabled>◄ Previous</button>
            <button id="nextPage" class="neon-button" disabled>Next ►</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const tableBody = document.querySelector('#dataTable tbody');
    const predictedNumberElement = document.getElementById('predictedNumber');
    const predictionCategoryElement = document.getElementById('predictionCategory');
    const predictedPremiumElement = document.getElementById('predictedPremium');
    const timerElement = document.getElementById('timeRemaining');
    const historyTableBody = document.querySelector('#predictionHistoryTable tbody');
    const prevPageButton = document.getElementById('prevPage');
    const nextPageButton = document.getElementById('nextPage');
    const errorMessageElement = document.getElementById('errorMessage');
    const warningMessageElement = document.getElementById('warningMessage');
    const successMessageElement = document.getElementById('successMessage');
    const infoMessageElement = document.getElementById('infoMessage');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const totalPredictionsElement = document.getElementById('totalPredictions');
    const accuracyRateElement = document.getElementById('accuracyRate');
    const lastResultElement = document.getElementById('lastResult');
    const currentStreakElement = document.getElementById('currentStreak');
    const smallBarElement = document.getElementById('smallBar');
    const bigBarElement = document.getElementById('bigBar');
    const heatMapElement = document.getElementById('heatMap');
    const trendIndicatorElement = document.getElementById('trendIndicator');
    const trendStrengthElement = document.getElementById('trendStrength');
    const notificationBell = document.getElementById('notificationBell');
    const notificationPanel = document.getElementById('notificationPanel');
    const notificationBadge = document.getElementById('notificationBadge');
    const notificationList = document.getElementById('notificationList');
    const settingsButton = document.getElementById('settingsButton');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsClose = document.getElementById('settingsClose');
    const saveSettingsButton = document.getElementById('saveSettings');
    const manualRefreshButton = document.getElementById('manualRefresh');
    const exportDataButton = document.getElementById('exportData');
    const algorithmTypeSelect = document.getElementById('algorithmType');
    const randomnessFactorInput = document.getElementById('randomnessFactor');
    const randomnessValueSpan = document.getElementById('randomnessValue');
    const themeSelect = document.getElementById('themeSelect');
    const animationsToggle = document.getElementById('animationsToggle');
    const soundToggle = document.getElementById('soundToggle');
    const vibrationToggle = document.getElementById('vibrationToggle');

    // Data state
    let predictionHistory = [];
    let lastPrediction = null;
    let currentPrediction = null;
    let currentPage = 0;
    const itemsPerPage = 10;
    let timerInterval = null;
    let isFetching = false;
    let systemStatus = 'initializing';
    let notifications = [];
    let settings = {
        algorithmType: 'advanced',
        randomnessFactor: 15,
        theme: 'default',
        animations: true,
        sound: true,
        vibration: false
    };
    let currentStreak = 0;

    // Initialize the app
    function init() {
        try {
            // Show loading state
            systemStatus = 'loading';
            updateSystemStatus();
            loadingSpinner.style.display = 'block';

            // Load saved data from localStorage
            const savedHistory = localStorage.getItem('predictionHistory');
            predictionHistory = savedHistory ? JSON.parse(savedHistory) : [];
            
            lastPrediction = JSON.parse(localStorage.getItem('lastPrediction'));
            currentPrediction = JSON.parse(localStorage.getItem('currentPrediction'));
            
            // Load settings
            const savedSettings = localStorage.getItem('systemSettings');
            if (savedSettings) {
                settings = JSON.parse(savedSettings);
                applySettingsToUI();
            }
            
            // Load notifications
            const savedNotifications = localStorage.getItem('notifications');
            if (savedNotifications) {
                notifications = JSON.parse(savedNotifications);
                updateNotificationBadge();
            }

            // Initialize heatmap
            initializeHeatMap();

            // Update stats
            updateStats();
            updatePatternAnalysis();
            updateTrendAnalysis();

            // Update UI with initial data
            updatePredictionHistoryTable();
            updateUI();

            // Start the update cycle
            startUpdateCycle();
        } catch (error) {
            showError('System initialization failed: ' + error.message);
            console.error('Initialization error:', error);
        } finally {
            loadingSpinner.style.display = 'none';
        }
    }

    // Apply settings to UI elements
    function applySettingsToUI() {
        algorithmTypeSelect.value = settings.algorithmType;
        randomnessFactorInput.value = settings.randomnessFactor;
        randomnessValueSpan.textContent = settings.randomnessFactor + '%';
        themeSelect.value = settings.theme;
        animationsToggle.checked = settings.animations;
        soundToggle.checked = settings.sound;
        vibrationToggle.checked = settings.vibration;
    }

    // Initialize heatmap
    function initializeHeatMap() {
        heatMapElement.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const cell = document.createElement('div');
            cell.className = 'heat-cell';
            cell.textContent = i;
            cell.id = `heat-cell-${i}`;
            cell.style.backgroundColor = 'rgba(0, 243, 255, 0.1)';
            heatMapElement.appendChild(cell);
        }
    }

    // Start the periodic update cycle
    function startUpdateCycle() {
        // Clear any existing interval
        if (timerInterval) {
            clearInterval(timerInterval);
        }

        // Immediate update
        updateData();

        // Set up periodic updates (every 10 seconds)
        timerInterval = setInterval(updateData,2170);
    }

    // Main update function
    async function updateData() {
        if (isFetching) return;
        isFetching = true;
        systemStatus = 'updating';
        updateSystemStatus();
        loadingSpinner.style.display = 'block';
        errorMessageElement.textContent = '';

        try {
            // Fetch the latest data
            const [emerData, gameIssueData] = await Promise.all([
                fetchNoAverageEmerdList(),
                fetchGameIssue()
            ]);

            // Process the data
            if (emerData && emerData.data && emerData.data.list && emerData.data.list.length > 0) {
                updateDataTable(emerData.data.list);
                processNewData(emerData.data.list);
            } else {
                showWarning('No new data available from quantum interface');
            }

            if (gameIssueData && gameIssueData.data) {
                updateTimer(gameIssueData.data.endTime);
            } else {
                showWarning('Could not sync with time server');
            }

            updateUI();
            systemStatus = 'operational';
            updateSystemStatus();
            showSuccess('Data synchronized successfully');
        } catch (error) {
            systemStatus = 'error';
            updateSystemStatus();
            showError('Data synchronization failed: ' + error.message);
            console.error('Update error:', error);
        } finally {
            isFetching = false;
            loadingSpinner.style.display = 'none';
        }
    }

    // Update the data table with new results
    function updateDataTable(dataList) {
        tableBody.innerHTML = '';
        dataList.forEach(item => {
            const numberCategory = categorizeNumber(Number(item.number));
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.issueNumber}</td>
                <td>${item.number} (${numberCategory})</td>
                <td>${item.colour || '--'}</td>
                <td>${item.premium || '--'}</td>
                <td>${new Date().toLocaleTimeString()}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    // Process new data and update predictions
    function processNewData(dataList) {
        const latestItem = dataList[0];
        const latestIssue = latestItem.issueNumber;
        const latestActual = Number(latestItem.number);
        const actualCategory = categorizeNumber(latestActual);

        // Check if we have a new issue
        if (!lastPrediction || lastPrediction.issueNumber !== latestIssue) {
            // If we had a previous prediction, record its accuracy
            if (lastPrediction) {
                const isCorrect = lastPrediction.category === actualCategory;
                
                // Update streak
                if (isCorrect) {
                    currentStreak++;
                    addNotification('Prediction Correct', `Successfully predicted ${lastPrediction.category} for issue ${latestIssue}`, 'success');
                } else {
                    currentStreak = 0;
                    addNotification('Prediction Incorrect', `Predicted ${lastPrediction.category} but got ${actualCategory} for issue ${latestIssue}`, 'error');
                }

                const newHistoryEntry = {
                    issueNumber: latestIssue,
                    predictedNumber: lastPrediction.number,
                    predictedCategory: lastPrediction.category,
                    actualNumber: latestActual,
                    actualCategory: actualCategory,
                    result: isCorrect ? '✓' : '✗',
                    timestamp: new Date().toISOString()
                };

                predictionHistory.unshift(newHistoryEntry);
                
                // Keep only the last 100 entries to prevent memory issues
                if (predictionHistory.length > 100) {
                    predictionHistory = predictionHistory.slice(0, 100);
                }

                localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));
                updateStats();
                updatePatternAnalysis();
                updateTrendAnalysis();
                updateHeatMap();
            }

            // Generate a new prediction
            currentPrediction = generatePrediction();
            currentPrediction.issueNumber = latestIssue;
            localStorage.setItem('currentPrediction', JSON.stringify(currentPrediction));

            // Update last prediction reference
            lastPrediction = {
                issueNumber: latestIssue,
                number: currentPrediction.number,
                category: currentPrediction.category
            };
            localStorage.setItem('lastPrediction', JSON.stringify(lastPrediction));
            
            // Add notification for new prediction
            addNotification('New Prediction Generated', `Predicted ${currentPrediction.category} (${currentPrediction.number}) for next issue with ${currentPrediction.confidence}% confidence`, 'info');
        }
    }

    // Update the timer display
    function updateTimer(endTime) {
        const endDate = new Date(endTime);
        const now = new Date();
        const remainingTimeMs = endDate - now;

        if (remainingTimeMs <= 0) {
            timerElement.textContent = "00:00:00";
            // Trigger an immediate update when time runs out
            setTimeout(updateData, 500);
        } else {
            const hours = String(Math.floor(remainingTimeMs / 3600000)).padStart(2, '0');
            const minutes = String(Math.floor((remainingTimeMs % 3600000) / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((remainingTimeMs % 60000) / 1000)).padStart(2, '0');
            timerElement.textContent = `${hours}:${minutes}:${seconds}`;
        }
    }

    // Update the UI with current data
    function updateUI() {
        // Update prediction display
        if (currentPrediction) {
            predictedNumberElement.textContent = currentPrediction.number;
            predictionCategoryElement.textContent = `Category: ${currentPrediction.category}`;
            predictedPremiumElement.textContent = `${currentPrediction.confidence}%`;
        } else {
            predictedNumberElement.textContent = '--';
            predictionCategoryElement.textContent = 'Category: --';
            predictedPremiumElement.textContent = '--%';
        }

        // Update history table
        updatePredictionHistoryTable();
    }

    // Update system status display
    function updateSystemStatus() {
        const statusMessages = {
            'initializing': 'Initializing quantum neural network...',
            'loading': 'Loading historical data patterns...',
            'updating': 'Synchronizing with quantum interface...',
            'operational': 'System operational - predictions active',
            'error': 'System error detected - attempting recovery'
        };
        
        const statusElement = document.querySelector('.status-message');
        if (statusElement) {
            statusElement.textContent = statusMessages[systemStatus] || 'System status unknown';
        }
    }

    // Update the stats display
    function updateStats() {
        totalPredictionsElement.textContent = predictionHistory.length;
        currentStreakElement.textContent = currentStreak;
        currentStreakElement.style.color = currentStreak > 2 ? 'var(--success-green)' : 
                                         currentStreak > 0 ? 'var(--warning-yellow)' : 'var(--error-red)';
        
        if (predictionHistory.length > 0) {
            const correctPredictions = predictionHistory.filter(entry => entry.result === '✓').length;
            const accuracy = Math.round((correctPredictions / predictionHistory.length) * 100);
            accuracyRateElement.textContent = `${accuracy}%`;
            
            if (predictionHistory[0]) {
                lastResultElement.textContent = predictionHistory[0].result;
                lastResultElement.style.color = predictionHistory[0].result === '✓' ? 'var(--matrix-green)' : 'var(--error-red)';
            }
        } else {
            accuracyRateElement.textContent = '0%';
            lastResultElement.textContent = '--';
        }
    }

    // Update pattern analysis display
    function updatePatternAnalysis() {
        if (predictionHistory.length === 0) return;
        
        const smallCount = predictionHistory.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = predictionHistory.filter(entry => entry.actualNumber >= 5).length;
        const total = smallCount + bigCount;
        
        const smallPercent = Math.round((smallCount / total) * 100);
        const bigPercent = Math.round((bigCount / total) * 100);
        
        smallBarElement.style.width = `${smallPercent}%`;
        smallBarElement.textContent = `Small: ${smallPercent}%`;
        bigBarElement.style.width = `${bigPercent}%`;
        bigBarElement.textContent = `Big: ${bigPercent}%`;
    }

    // Update trend analysis display
    function updateTrendAnalysis() {
        if (predictionHistory.length < 3) {
            trendIndicatorElement.textContent = '--';
            trendStrengthElement.textContent = 'Strength: --';
            return;
        }
        
        // Get last 5 results (or all if less than 5)
        const recentResults = predictionHistory.slice(0, 5);
        const smallCount = recentResults.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = recentResults.filter(entry => entry.actualNumber >= 5).length;
        
        const smallPercent = (smallCount / recentResults.length) * 100;
        const bigPercent = (bigCount / recentResults.length) * 100;
        
        // Determine trend direction
        if (smallPercent > 60) {
            trendIndicatorElement.textContent = 'Small ▲';
            trendIndicatorElement.className = 'prediction-value trend-up';
            trendStrengthElement.textContent = `Strength: ${Math.round(smallPercent)}%`;
        } else if (bigPercent > 60) {
            trendIndicatorElement.textContent = 'Big ▲';
            trendIndicatorElement.className = 'prediction-value trend-up';
            trendStrengthElement.textContent = `Strength: ${Math.round(bigPercent)}%`;
        } else {
            trendIndicatorElement.textContent = 'Neutral ➝';
            trendIndicatorElement.className = 'prediction-value trend-neutral';
            trendStrengthElement.textContent = 'Strength: Mixed';
        }
    }

    // Update heatmap display
    function updateHeatMap() {
        if (predictionHistory.length === 0) return;
        
        // Count occurrences of each number in recent history
        const numberCounts = Array(10).fill(0);
        const recentHistory = predictionHistory.slice(0, 100); // Last 20 results
        
        recentHistory.forEach(entry => {
            numberCounts[entry.actualNumber]++;
        });
        
        // Find max count for normalization
        const maxCount = Math.max(...numberCounts);
        
        // Update heatmap cells
        for (let i = 0; i < 10; i++) {
            const cell = document.getElementById(`heat-cell-${i}`);
            if (!cell) continue;
            
            const count = numberCounts[i];
            const intensity = maxCount > 0 ? (count / maxCount) : 0;
            
            // Set color based on intensity
            if (intensity > 0.7) {
                cell.style.backgroundColor = `rgba(255, 0, 0, ${0.3 + intensity * 0.7})`;
            } else if (intensity > 0.4) {
                cell.style.backgroundColor = `rgba(255, 165, 0, ${0.3 + intensity * 0.7})`;
            } else {
                cell.style.backgroundColor = `rgba(0, 243, 255, ${0.1 + intensity * 0.7})`;
            }
            
            // Add count tooltip
            cell.title = `Appeared ${count} time${count !== 1 ? 's' : ''} in last ${recentHistory.length} results`;
        }
    }

    // Update the prediction history table
    function updatePredictionHistoryTable() {
        historyTableBody.innerHTML = '';
        
        if (predictionHistory.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="5">No prediction history available</td>';
            historyTableBody.appendChild(row);
            return;
        }

        const start = currentPage * itemsPerPage;
        const end = start + itemsPerPage;
        const paginatedHistory = predictionHistory.slice(start, end);

        paginatedHistory.forEach(entry => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${entry.issueNumber}</td>
                <td>${entry.predictedNumber} (${entry.predictedCategory})</td>
                <td>${entry.actualNumber} (${entry.actualCategory})</td>
                <td style="color: ${entry.result === '✓' ? 'var(--matrix-green)' : 'var(--error-red)'}">${entry.result}</td>
                <td>${new Date(entry.timestamp).toLocaleTimeString()}</td>
            `;
            historyTableBody.appendChild(row);
        });

        // Update pagination buttons
        prevPageButton.disabled = currentPage === 0 || predictionHistory.length === 0;
        nextPageButton.disabled = end >= predictionHistory.length || predictionHistory.length === 0;
    }

    // Generate a new prediction
    function generatePrediction() {
        let prediction;
        
        switch(settings.algorithmType) {
            case 'basic':
                prediction = generateBasicPrediction();
                break;
            case 'quantum':
                prediction = generateQuantumPrediction();
                break;
            case 'advanced':
            default:
                prediction = generateAdvancedPrediction();
                break;
        }
        
        return prediction;
    }

    // Basic prediction algorithm (simple random)
    function generateBasicPrediction() {
        const predictedNumber = Math.floor(Math.random() * 10);
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.floor(Math.random() * 30) + 50 // 50-80%
        };
    }

    // Advanced prediction algorithm (history-based)
    function generateAdvancedPrediction() {
        if (predictionHistory.length === 0) {
            return generateBasicPrediction();
        }
        
        const smallCount = predictionHistory.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = predictionHistory.filter(entry => entry.actualNumber >= 5).length;
        
        const total = smallCount + bigCount;
        const smallProbability = total ? (smallCount / total) : 0.5;
        
        // Add weighted randomness based on settings
        const randomFactor = (Math.random() * settings.randomnessFactor / 50) - (settings.randomnessFactor / 100);
        const adjustedProbability = Math.max(0.1, Math.min(0.9, smallProbability + randomFactor));
        
        // Generate number with weighted probability
        const predictedNumber = Math.random() < adjustedProbability ? 
            Math.floor(Math.random() * 5) : // Small number (0-4)
            Math.floor(Math.random() * 5) + 5; // Big number (5-9)
            
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.round(adjustedProbability * 100)
        };
    }

    // Quantum simulation prediction (more complex pattern recognition)
    function generateQuantumPrediction() {
        if (predictionHistory.length < 5) {
            return generateAdvancedPrediction();
        }
        
        // Analyze recent patterns
        const recentResults = predictionHistory.slice(0, 10);
        const smallCount = recentResults.filter(entry => entry.actualNumber <= 4).length;
        const bigCount = recentResults.filter(entry => entry.actualNumber >= 5).length;
        
        // Calculate probabilities with momentum
        const smallProbability = (smallCount / recentResults.length) * 1.2; // Slight bias towards continuing trend
        const bigProbability = (bigCount / recentResults.length) * 1.2;
        
        // Normalize probabilities
        const total = smallProbability + bigProbability;
        const normalizedSmall = smallProbability / total;
        
        // Add randomness based on settings
        const randomFactor = (Math.random() * settings.randomnessFactor / 100) - (settings.randomnessFactor / 200);
        const adjustedProbability = Math.max(0.1, Math.min(0.9, normalizedSmall + randomFactor));
        
        // Generate prediction
        const predictedNumber = Math.random() < adjustedProbability ? 
            Math.floor(Math.random() * 5) : // Small number (0-4)
            Math.floor(Math.random() * 5) + 5; // Big number (5-9)
            
        return { 
            number: predictedNumber, 
            category: categorizeNumber(predictedNumber),
            confidence: Math.round(adjustedProbability * 100)
        };
    }

    // Categorize numbers as Small (0-4) or Big (5-9)
    function categorizeNumber(number) {
        return (number >= 0 && number <= 4) ? 'Small' : 'Big';
    }

    // API fetch functions with error handling
    async function fetchNoAverageEmerdList() {
        try {
            const requestData = {
                pageSize: 10,
                pageNo: 1,
                typeId: 1,
                language: 0,
                random: "ded40537a2ce416e96c00e5218f6859a",
                signature: "69306982EEEB19FA940D72EC93C62552",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching no average EMERD list:', error);
            throw error;
        }
    }

    async function fetchGameIssue() {
        try {
            const requestData = {
                typeId: 1,
                language: 0,
                random: "f8dcb5c527814db68800e3946a2b60e8",
                signature: "08CF7FF3339ED58D4743F4B650FCBEA9",
                timestamp: Math.floor(Date.now() / 1000)
            };

            const response = await fetch('https://api.bdg88zf.com/api/webapi/GetGameIssue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching game issue:', error);
            throw error;
        }
    }

    // Show error message
    function showError(message) {
        errorMessageElement.textContent = message;
        console.error(message);
        addNotification('System Error', message, 'error');
    }

    // Show warning message
    function showWarning(message) {
        warningMessageElement.textContent = message;
        console.warn(message);
        setTimeout(() => warningMessageElement.textContent = '', 5000);
        addNotification('System Warning', message, 'warning');
    }

    // Show success message
    function showSuccess(message) {
        successMessageElement.textContent = message;
        console.log(message);
        setTimeout(() => successMessageElement.textContent = '', 5000);
    }

    // Show info message
    function showInfo(message) {
        infoMessageElement.textContent = message;
        console.log(message);
        setTimeout(() => infoMessageElement.textContent = '', 5000);
    }

    // Add notification
    function addNotification(title, message, type) {
        const newNotification = {
            id: Date.now(),
            title,
            message,
            type,
            timestamp: new Date().toISOString()
        };
        
        notifications.unshift(newNotification);
        
        // Keep only the last 20 notifications
        if (notifications.length > 20) {
            notifications = notifications.slice(0, 20);
        }
        
        // Save to localStorage
        localStorage.setItem('notifications', JSON.stringify(notifications));
        
        // Update UI
        updateNotificationBadge();
        updateNotificationList();
        
        // Play sound if enabled
        if (settings.sound) {
            playNotificationSound(type);
        }
        
        // Vibrate if enabled
        if (settings.vibration && navigator.vibrate) {
            navigator.vibrate(type === 'error' ? [200, 100, 200] : [200]);
        }
    }

    // Play notification sound
    function playNotificationSound(type) {
        // In a real app, you would play actual sounds here
        console.log(`Playing ${type} notification sound`);
    }

    // Update notification badge
    function updateNotificationBadge() {
        const unreadCount = notifications.length;
        notificationBadge.textContent = unreadCount;
        notificationBadge.style.display = unreadCount > 0 ? 'flex' : 'none';
    }

    // Update notification list
    function updateNotificationList() {
        notificationList.innerHTML = '';
        
        if (notifications.length === 0) {
            notificationList.innerHTML = '<div class="notification-item">No notifications</div>';
            return;
        }
        
        notifications.forEach(notification => {
            const item = document.createElement('div');
            item.className = `notification-item ${notification.type}`;
            item.innerHTML = `
                <strong>${notification.title}</strong>
                <p>${notification.message}</p>
                <div class="notification-time">${new Date(notification.timestamp).toLocaleTimeString()}</div>
            `;
            notificationList.appendChild(item);
        });
    }

    // Export data as CSV
    function exportData() {
        if (predictionHistory.length === 0) {
            showWarning('No data available to export');
            return;
        }
        
        // Prepare CSV content
        let csvContent = "Issue,Predicted Number,Predicted Category,Actual Number,Actual Category,Result,Timestamp\n";
        
        predictionHistory.forEach(entry => {
            csvContent += `"${entry.issueNumber}","${entry.predictedNumber}","${entry.predictedCategory}","${entry.actualNumber}","${entry.actualCategory}","${entry.result}","${entry.timestamp}"\n`;
        });
        
        // Create download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `surya_ai_predictions_${new Date().toISOString().slice(0, 10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showSuccess('Data exported successfully');
    }

    // Event listeners
    prevPageButton.addEventListener('click', () => {
        if (currentPage > 0) {
            currentPage--;
            updatePredictionHistoryTable();
        }
    });

    nextPageButton.addEventListener('click', () => {
        if ((currentPage + 1) * itemsPerPage < predictionHistory.length) {
            currentPage++;
            updatePredictionHistoryTable();
        }
    });

    notificationBell.addEventListener('click', () => {
        notificationPanel.style.display = notificationPanel.style.display === 'block' ? 'none' : 'block';
        if (notificationPanel.style.display === 'block') {
            updateNotificationList();
        }
    });

    settingsButton.addEventListener('click', () => {
        settingsPanel.style.display = 'block';
    });

    settingsClose.addEventListener('click', () => {
        settingsPanel.style.display = 'none';
    });

    saveSettingsButton.addEventListener('click', () => {
        // Save settings
        settings = {
            algorithmType: algorithmTypeSelect.value,
            randomnessFactor: parseInt(randomnessFactorInput.value),
            theme: themeSelect.value,
            animations: animationsToggle.checked,
            sound: soundToggle.checked,
            vibration: vibrationToggle.checked
        };
        
        localStorage.setItem('systemSettings', JSON.stringify(settings));
        settingsPanel.style.display = 'none';
        showSuccess('Settings saved successfully');
    });

    randomnessFactorInput.addEventListener('input', () => {
        randomnessValueSpan.textContent = randomnessFactorInput.value + '%';
    });

    manualRefreshButton.addEventListener('click', () => {
        updateData();
    });

    exportDataButton.addEventListener('click', () => {
        exportData();
    });

    // Close notifications when clicking outside
    document.addEventListener('click', (event) => {
        if (!notificationBell.contains(event.target) && !notificationPanel.contains(event.target)) {
            notificationPanel.style.display = 'none';
        }
        
        if (!settingsButton.contains(event.target) && !settingsPanel.contains(event.target) && 
            event.target !== settingsPanel && !settingsClose.contains(event.target)) {
            settingsPanel.style.display = 'none';
        }
    });

    // Initialize the application
    init();
});
</script>
</body>
</html>